# Finds the optimal local modulus value to replace undefined voxels and number
# of voxels to omit from top and bottom layers using a grid search.
# Local modulus field must be generated by running ../../machine_learning/Grad-CAM/local_modulus_field.py
# prior to running this scipt.

import numpy as np
import matplotlib.pyplot as plt

def E_volume_integral_func(E_local):
    
    N = E_local.shape[0]
    Lx = E_local.shape[1]
    Ly = E_local.shape[2]
    Lz = E_local.shape[3]

    E = np.zeros(N)

    for dx in range(Lx):
        for dy in range(Ly):
            E += 1/np.sum(1/E_local[:,dx,dy,:],axis=1)
    return Lz/(Lx*Ly) * E

def E_reuss_func(E_local):
    return 1/np.sum(1/E_local, axis=(1,2,3))*np.prod(E_local.shape[1:])

def E_voigt_func(E_local):
    return np.sum(E_local, axis=(1,2,3))/np.prod(E_local.shape[1:])

def E_hill_func(E_local):
    return np.mean([E_reuss_func(E_local), E_voigt_func(E_local)], axis=0)


def r_2(y_true, y_pred):
    RSS =  np.sum(np.square(y_true - y_pred))
    TSS = np.sum(np.square(y_true - np.mean(y_true)))
    return ( 1 - (RSS/TSS) )

global_modulus_tr_val_set = np.load('../../machine_learning/ground_truth/tr_val_set/moduluses_0.0015.npy')
global_modulus_test_set = np.load('../../machine_learning/ground_truth/test_set/moduluses_0.0015.npy')

E_funcs = [E_voigt_func, E_reuss_func, E_hill_func, E_volume_integral_func]
titles = ['voigt', 'reus', 'hill', 'volume integral']

resolutions = [16, 32]
peelzs = [[2, 3, 4],
          [5, 6, 7]]
peelxy = 0

replace_values = np.arange(80, 130)

data = {}

for title, E_func in zip(titles, E_funcs):
    for i_res, res in enumerate(resolutions):

        # Make sure local modulus field is generated
        local_modulus_field_tr_val_set = np.load(f'../../machine_learning/Grad-CAM/local_modulus_field_tr_val_set_{res}.npy')

        key = f'{title} {res}'
        print(key)
        grid = np.zeros((len(peelzs[i_res]), len(replace_values)))
        for i_peel, peelz in enumerate(peelzs[i_res]):
            for i_replace, replace_value in enumerate(replace_values):


                N = local_modulus_field_tr_val_set.shape[0]
                mask_inner = np.zeros_like(local_modulus_field_tr_val_set, dtype=bool)
                mask_inner[:, peelxy:res-peelxy, peelxy:res-peelxy, peelz:2*res-peelz] = True
                local_modulus_field = local_modulus_field_tr_val_set[mask_inner].reshape(N, res-2*peelxy, res-2*peelxy, 2*res-2*peelz)

                local_modulus_field[local_modulus_field==0] = replace_value

                E_estimate = E_func(local_modulus_field)
                r2 = r_2((E_estimate-np.mean(E_estimate))/np.std(E_estimate),
                         (global_modulus_tr_val_set-np.mean(global_modulus_tr_val_set))/np.std(global_modulus_tr_val_set))
                grid[i_peel, i_replace] = r2

        plt.figure()
        plt.imshow(grid, extent=[replace_values[0], replace_values[-1], peelzs[i_res][-1], peelzs[i_res][0]], aspect='auto')
        plt.colorbar()
        plt.title(key)

        data[key] = grid

plt.show()

np.savez('grid_search_data.npz', **data)

data = np.load('grid_search_data.npz')

y_preds = {}
y_preds_tr_val = {}

fig, axs = plt.subplots(2, 4)

for i_func in range(len(E_funcs)):
    for i_res, res in enumerate(resolutions):

        local_modulus_field_test_set = np.load(f'../../machine_learning/Grad-CAM/local_modulus_field_test_set_{res}.npy')
        local_modulus_field_tr_val_set = np.load(f'../../machine_learning/Grad-CAM/local_modulus_field_tr_val_set_{res}.npy')

        title = titles[i_func]
        key = f'{title} {res}'
        print(key)
        grid = data[key]

        max_idx_flat = np.argmax(grid)
        max_idx = np.unravel_index(max_idx_flat, grid.shape)
        peelz = peelzs[i_res][max_idx[0]]
        replace_value = replace_values[max_idx[1]]

        N = local_modulus_field_test_set.shape[0]
        mask_inner = np.zeros_like(local_modulus_field_test_set, dtype=bool)
        mask_inner[:, peelxy:res-peelxy, peelxy:res-peelxy, peelz:2*res-peelz] = True
        local_modulus_field_test_set = local_modulus_field_test_set[mask_inner].reshape(N, res-2*peelxy, res-2*peelxy, 2*res-2*peelz)
        local_modulus_field_test_set[local_modulus_field_test_set==0] = replace_value

        N = local_modulus_field_tr_val_set.shape[0]
        mask_inner = np.zeros_like(local_modulus_field_tr_val_set, dtype=bool)
        mask_inner[:, peelxy:res-peelxy, peelxy:res-peelxy, peelz:2*res-peelz] = True
        local_modulus_field_tr_val_set = local_modulus_field_tr_val_set[mask_inner].reshape(N, res-2*peelxy, res-2*peelxy, 2*res-2*peelz)
        local_modulus_field_tr_val_set[local_modulus_field_tr_val_set==0] = replace_value

        E_func = E_funcs[i_func]
        E_estimate_test_set = E_func(local_modulus_field_test_set)
        E_estimate_tr_val_set = E_func(local_modulus_field_tr_val_set)

        E_estimate_test_set_scaled = (E_estimate_test_set-np.mean(E_estimate_tr_val_set))/np.std(E_estimate_tr_val_set) * np.std(global_modulus_tr_val_set)+np.mean(global_modulus_tr_val_set)

        r2 = r_2(global_modulus_test_set, E_estimate_test_set_scaled) 

        y_preds[key] = E_estimate_test_set
        y_preds_tr_val[key] = E_estimate_tr_val_set

        print(r2)

        ax = axs[i_res, i_func]
        ax.scatter(global_modulus_test_set, E_estimate_test_set, s=0.5)
        ax.text(0.05, 0.95, f'r2: {r2:.4f}', transform=ax.transAxes, verticalalignment='top', fontsize=9)
        ax.set_title(title)
        ax.set_xlabel('true modulus (GPa)')
        ax.set_ylabel('predicted modulus (GPa)')



np.savez('y_preds_direct.npz', **y_preds)
np.savez('y_preds_direct_tr_val.npz', **y_preds_tr_val)

plt.show()

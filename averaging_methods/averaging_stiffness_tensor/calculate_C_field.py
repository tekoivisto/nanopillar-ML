# Calculates local stiffness tensors C(r) based on local lattice orientations
# and stiffness coefficients of the cubic crystal. The quaternion
# descriptor must generated by running ../../machine_learning/descriptors/descriptors.py
# prior to running this script.

import numpy as np
from scipy.spatial.transform import Rotation


def rotate_stifness_tensor(stifness_tensor, rotation_matrix):
    # Adapted from https://jakubmikula.com/solidmechanics/2017/06/18/Cubic-Elasticity.html
    
    C = stifness_tensor

    R = np.identity(6, dtype=float)
    for i in range(3,6):
        R[i,i]=2

    invR = np.identity(6, dtype=float)
    for i in range(3,6):
        invR[i,i]=0.5

    R_cg = rotation_matrix
    
    mmod = np.array([[1, 1, 1, 1, 1],
                    [-1, 2, 2, 2, 2],
                    [0, 0, 3, 3, 3],
                    [1, 1, 1, 4, 4],
                    [2, 2, 2, 2, 5]])

    mmod -= 1

    K = [np.zeros((3,3)) for _ in range(4)]

    for i in range(3):
        for j in range(3):

            K[0][i,j] = R_cg[i,j]**2
            K[1][i,j] = R_cg[i,mmod[j+1,2]]*R_cg[i,mmod[j+2,2]]
            K[2][i,j] = R_cg[mmod[i+1,2],j]*R_cg[mmod[i+2,2],j]
            K[3][i,j] = R_cg[mmod[i+1,2],mmod[j+1,2]]*R_cg[mmod[i+2,2],mmod[j+2,2]] + R_cg[mmod[i+1,2],mmod[j+2,2]]*R_cg[mmod[i+2,2],mmod[j+1,2]]

    T_cg = np.zeros((6,6))

    T_cg[0:3,0:3] = K[0]
    T_cg[0:3,3:6] = 2*K[1]
    T_cg[3:6,0:3] = K[2]
    T_cg[3:6,3:6] = K[3]

    invT_cg = np.zeros((6,6))
    invT_cg[0:3,0:3] = K[0].T
    invT_cg[0:3,3:6] = 2*K[2].T
    invT_cg[3:6,0:3] = K[1].T
    invT_cg[3:6,3:6] = K[3].T

    # Rotated tensor of elastic constants
    C_rot = T_cg@C@R@invT_cg@invR
    return C_rot


def load_compliance_constants():
    stiffness_constants = np.loadtxt('../../molecular_dynamics/elastic_coefficients/elasticity_matrix.txt')
    stiffness_constants = np.triu(stiffness_constants) + np.tril(stiffness_constants.T, -1)
    
    compliance_constants = np.linalg.inv(stiffness_constants)

    s_11 = np.mean(compliance_constants[[0,1,2],
                                        [0,1,2]])
    s_12 = np.mean(compliance_constants[[0,0,1],
                                        [1,2,2]])
    s_44 = np.mean(compliance_constants[[3,4,5],
                                        [3,4,5]])
    return s_11, s_12, s_44


set_ = 'tr_val'
#set_ = 'test'

def main():
    # Calculates local C(r) field

    res = 16

    s_11, s_12, s_44 = load_compliance_constants()
    # Make sure quaternions are generated
    quaternions = np.load(f'../../machine_learning/descriptors/quaternion_vanilla_boundary_{set_}_set_{res}.npy')
    
    S = np.array([[s_11, s_12, s_12, 0,    0,    0   ],
                  [s_12, s_11, s_12, 0,    0,    0   ],
                  [s_12, s_12, s_11, 0,    0,    0   ],
                  [0,    0,    0,    s_44, 0,    0   ],
                  [0,    0,    0,    0,    s_44, 0   ],
                  [0,    0,    0,    0,    0,    s_44]])
    
    C = np.linalg.inv(S)

    C_field = np.zeros(list(quaternions.shape[:-1]) + [6,6], dtype=np.float32)

    nonzero_quaternion_indices = np.argwhere(~np.all(np.isclose(quaternions, 0), axis=-1))
    
    # for tracking progress
    n_tot = len(nonzero_quaternion_indices)
    n_checkpoint = n_tot//500

    for i, index in enumerate(nonzero_quaternion_indices):
        if i%n_checkpoint==0:
            print(f'{i//n_checkpoint}/500')

        i_pillar, i_x, i_y, i_z = index
        quat = quaternions[i_pillar, i_x, i_y, i_z]
        rot = Rotation.from_quat(quat)
        rot_matrix = rot.as_matrix()
        C_rot = rotate_stifness_tensor(C, rot_matrix)

        C_field[i_pillar, i_x, i_y, i_z] = C_rot

    np.save(f'C_field_{set_}_set_{res}.npy', C_field)


def calculate_mean():
    # Calculates C(r) averaged over the defined voxels

    res = 32
    peelz = 6

    s_11, s_12, s_44 = load_compliance_constants()
    quaternions = np.load(f'../../machine_learning/descriptors/quaternion_vanilla_boundary_{set_}_set_{res}.npy')

    S = np.array([[s_11, s_12, s_12, 0,    0,    0   ],
                  [s_12, s_11, s_12, 0,    0,    0   ],
                  [s_12, s_12, s_11, 0,    0,    0   ],
                  [0,    0,    0,    s_44, 0,    0   ],
                  [0,    0,    0,    0,    s_44, 0   ],
                  [0,    0,    0,    0,    0,    s_44]])
    
    C = np.linalg.inv(S)

    C_field_mean_nonzeros = np.zeros((quaternions.shape[0], 6, 6))
    nonzero_counts = np.zeros(quaternions.shape[0])

    nonzero_quaternion_indices = np.argwhere(~np.all(np.isclose(quaternions, 0), axis=-1))
    
    # for tracking progress
    n_tot = len(nonzero_quaternion_indices)
    n_checkpoint = n_tot//500

    for i, index in enumerate(nonzero_quaternion_indices):
        if i%n_checkpoint==0:
            print(f'{i//n_checkpoint}/500')

        i_pillar, i_x, i_y, i_z = index
        if i_z < peelz or i_z >= 2*res-peelz:
            continue

        quat = quaternions[i_pillar, i_x, i_y, i_z]
        rot = Rotation.from_quat(quat)
        rot_matrix = rot.as_matrix()
        C_rot = rotate_stifness_tensor(C, rot_matrix)

        C_field_mean_nonzeros[i_pillar] += C_rot

        nonzero_counts[i_pillar] += 1
    
    C_field_mean_nonzeros = C_field_mean_nonzeros/nonzero_counts[:, np.newaxis, np.newaxis]

    np.save(f'C_mean_nonzero_{set_}_set_{res}.npy', C_field_mean_nonzeros)
    np.save(f'nonzero_counts_{set_}_set_{res}.npy', nonzero_counts)

main()
# For the higher resoution of 32x32x64 the full field would use a lot of memory, so
# for that resolution only the tensor averaged over the defined voxels is stored.
calculate_mean()

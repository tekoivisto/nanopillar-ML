# Calculates the local Young's modulus field from the quaternion descriptor
# and compliance coefficients. Quaternion descriptor should be generated by
# running ../descriptors/descriptors.py prior to running this script.

import numpy as np
from scipy.spatial.transform import Rotation

def load_compliance_constants():
    stiffness_constants = np.loadtxt('../../molecular_dynamics/elastic_coefficients/elasticity_matrix.txt')
    stiffness_constants = np.triu(stiffness_constants) + np.tril(stiffness_constants.T, -1)
    
    compliance_constants = np.linalg.inv(stiffness_constants)

    s_11 = np.mean(compliance_constants[[0,1,2],
                                        [0,1,2]])
    s_12 = np.mean(compliance_constants[[0,0,1],
                                        [1,2,2]])
    s_44 = np.mean(compliance_constants[[3,4,5],
                                        [3,4,5]])
    return s_11, s_12, s_44

def modulus_along_l(l, s_11, s_12, s_44):

    lxsq, lysq, lzsq = (l**2).flatten()
    modulus = 1 / (s_11 - 2*(s_11 - s_12 - s_44/2) * (lxsq*lysq + lxsq*lzsq + lysq*lzsq))

    return modulus

def global_pillar_coords_to_local_lattice_coords(vec_global, quaternion):
    rot = Rotation.from_quat(quaternion)

    rot_matrix = rot.as_matrix()
    rot_matrix_inv = np.linalg.inv(rot_matrix)

    vec_local = rot_matrix_inv @ vec_global

    return vec_local

def main():

    #res = 16
    res = 32

    #set_ = 'tr_val'
    set_ = 'test'

    s_11, s_12, s_44 = load_compliance_constants()
    quaternions = np.load(f'../descriptors/quaternion_vanilla_boundary_{set_}_set_{res}.npy')
    
    k = np.array([[0], [0], [1]])

    local_modulus_field = np.zeros(quaternions.shape[:-1])

    nonzero_quaternion_indices = np.argwhere(~np.all(np.isclose(quaternions, 0), axis=-1))
    
    # for tracking progress
    n_tot = len(nonzero_quaternion_indices)
    n_checkpoint = n_tot//500

    for i, index in enumerate(nonzero_quaternion_indices):
        if i%n_checkpoint==0:
            print(f'{i//n_checkpoint}/500')

        i_pillar, i_x, i_y, i_z = index
        quat = quaternions[i_pillar, i_x, i_y, i_z]

        l = global_pillar_coords_to_local_lattice_coords(k, quat)

        modulus = modulus_along_l(l, s_11, s_12, s_44)
        
        local_modulus_field[i_pillar, i_x, i_y, i_z] = modulus

    np.save(f'local_modulus_field_{set_}_set_{res}.npy', local_modulus_field)


if __name__ == '__main__':
    main()

# Plots average Grad-CAM value in grains and grain boundaries. Grad-CAM fields
# must be loaded from Zenodo and grain boundary descriptor must be generated
# prior to running this script.

import numpy as np
from scipy.ndimage import zoom
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.ticker as ticker
from scipy.stats import pearsonr


plt.style.use('seaborn-v0_8-paper')
sns.set_context('paper')


cmap = plt.get_cmap('Blues')


y_ticks = [np.array([-0.5,0,0.5])*1e-2,
           np.array([0,0.5])*1e-2,
           np.array([-2,0,2])*1e-3,
           np.array([-2,0,2])*1e-3]


def plot_bars(ax, means, stds):

    x = np.arange(len(means))+1
    ax.bar(x, means, width=0.8)
    ax.errorbar(x, means, yerr=stds, fmt='none', ecolor='black', elinewidth=1, markeredgewidth=1)

def sci_format_func(value, pos):
    if value == 0:
        return '0'
    else:
        strr = f'{value:.0e}'.replace('e-0', 'e-')

        return strr

def sci_format_func_space(value, pos):
    if value == 0:
        return '0'
    else:
        strr = f' {value:.0e}'.replace('e-0', 'e-')

        return strr

def plot_bar_graphs():

    # Interpolation order for upscaling Grad-CAM fields. 0 for nearest, 1 for trinilear
    interpolation_order=1

    # Make sure Grad-CAM fields are loaded from Zenodo
    #heatmap_path = '../train_CNN/moduluses_0.0015/raw/128/'
    heatmap_path = '../train_CNN/yield_stress_0.005/raw/128/'
    
    # Make sure grain boundary field is generated by running ../descriptors/descriptors.py
    field_path = '../descriptors/grain_boundary_vanilla_boundary_test_set_32.npy'
    fields = np.load(field_path)

    N = fields.shape[0]

    res = fields.shape[1]
    # Pillars are "peeled" because surface are falsely considered as grain boundaries
    mask_inner = np.zeros_like(fields, dtype=bool)
    peel = 2
    mask_inner[:, peel:res-peel, peel:res-peel, peel:2*res-peel] = True
    fields = fields[mask_inner].reshape(N, res-2*peel, res-2*peel, 2*res-2*peel)

    masks_grain_boundary = [np.where(fields[i]==0, 0, 1).astype(bool) for i in range(N)]
    masks_grain = [np.where(fields[i]==0, 1, 0).astype(bool) for i in range(N)]

    n_conv_blocks = 4
    n_seeds = 5

    fig, axs = plt.subplots(n_conv_blocks, n_seeds)
    fig.set_size_inches(7.5,5)
    fig.subplots_adjust(wspace=0, hspace=0)

    label_added = False

    mask = np.array([True] * (N // 2) + [False] * (N // 2))
    np.random.shuffle(mask)

    plt.subplots_adjust(wspace=0, hspace=0)

    for conv_block_n in range(1, n_conv_blocks + 1):
        
        y_all_grain = []
        y_all_boundary = []

        for seed in range(1,n_seeds+1):

            print(conv_block_n, seed)

            y_pred = np.load(f'{heatmap_path}preds_test_set_augmented_{seed}.npy')            

            heatmaps = np.load(f'{heatmap_path}grad_cam_heatmaps_{seed}/conv_block_augmented_{conv_block_n}.npy')
            heatmaps*=np.prod(heatmaps.shape[1:])  # in the calculation of the grad cam fields, mean was used in one place where sum should have been used, which causes the fields to have a wrong scale


            if conv_block_n > 1:
                scale_factor = 2**(conv_block_n-1)
                hm = np.zeros((N, res, res, 2*res))
                for i, pillar in enumerate(heatmaps):
                    hm[i] = zoom(pillar, zoom=scale_factor, order=interpolation_order)
                heatmaps = hm
            
            heatmaps = heatmaps[mask_inner].reshape(N, res-2*peel, res-2*peel, 2*res-2*peel)

            means_grain_boundary = []
            means_grain = []
            
            for i in range(N):
                mask_grain_boundary = masks_grain_boundary[i]
                mask_grain = masks_grain[i]

                pillar = heatmaps[i]

                mean_grain_boundary = np.mean(pillar[mask_grain_boundary])
                means_grain_boundary.append(mean_grain_boundary)
                mean_grain = np.mean(pillar[mask_grain])
                means_grain.append(mean_grain)
            
            s = 0.01

            means_grain = np.array(means_grain)
            ax = axs[conv_block_n-1, seed-1]
            ax.scatter(y_pred[mask], means_grain[mask], s=s, color='tab:blue')
            ax.scatter(y_pred, means_grain_boundary, s=s, color='tab:red')
            ax.scatter(y_pred[~mask], means_grain[~mask], s=s, color='tab:blue')

            if not label_added:
                label_added = True
                ax.scatter([-100, -100], [-100, -100], color='tab:blue', label='grain')
                ax.scatter([-100, -100], [-100, -100], color='tab:red', label='grain boundary')
            
            y_all_grain.append(means_grain)
            y_all_boundary.append(means_grain_boundary)


        y_all_grain = np.array(y_all_grain)
        y_all_boundary = np.array(y_all_boundary)
        for i, (y_grain, y_boundary) in enumerate(zip(y_all_grain, y_all_boundary)):
            ax = axs[conv_block_n-1, i]

            p = 0.1
            y_max = max(np.percentile(y_all_boundary, 100-p), np.percentile(y_all_grain, 100-p))
            y_min = min(np.percentile(y_all_boundary, p), np.percentile(y_all_grain, p))
            ax.set_ylim([y_min, y_max])
            ax.set_xlim([np.percentile(y_pred, p), np.percentile(y_pred, 100-p)])

            width=1
            ax.tick_params(axis="both", which='both', direction="in")
            ax.tick_params(axis='x', which='major', length=3.5, width=width)
            ax.tick_params(axis='y', which='major', length=3.5, width=width)

            ax.set_yticks(y_ticks[conv_block_n-1])

            if i == 0:
                if conv_block_n ==2:
                    ax.yaxis.set_major_formatter(ticker.FuncFormatter(sci_format_func_space))
                else:
                    ax.yaxis.set_major_formatter(ticker.FuncFormatter(sci_format_func))
                ax.set_ylabel(f'conv block {conv_block_n}\nGrad-CAM\naverage')

            else:
                ax.set_yticklabels([])

            if conv_block_n == 1:
                ax.set_title(f'CNN {i+1}')
            elif conv_block_n == n_conv_blocks and i==2:
                ax.set_xlabel('predicted yield stress (GPa)')
            
            fig.subplots_adjust(right=0.78)

            fig.legend(loc = 'center right')

    fname = 'avg_grad_cam'
    fig.savefig(fname+'.pdf', bbox_inches='tight')
    fig.savefig(fname+'.png', bbox_inches='tight', dpi=300)
    plt.show()


plot_bar_graphs()
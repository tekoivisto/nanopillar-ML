# Plots point clouds of Grad-CAM vs local modulus. Grad-CAM fields must be
# loaded from Zenodo and local Young's modulus field must be generated prior to
# running this script.

import numpy as np
from scipy.ndimage import zoom
import matplotlib.pyplot as plt
import pandas as pd
import datashader as ds
import matplotlib.colors as mcolors
import seaborn as sns
import matplotlib.ticker as ticker
from scipy.stats import pearsonr
import matplotlib.gridspec as gridspec


plt.style.use('seaborn-v0_8-paper')
sns.set_context('paper')


cmap = plt.get_cmap('Blues')


y_ticks = [np.array([-0.5,0,0.5])*1e-2,
           np.array([-0.5,0,0.5])*1e-2,
           np.array([-3,0,3])*1e-3,
           np.array([-3,0,3])*1e-3]


def plot_density(ax, x, y, yrange):
    points = np.vstack((x,y)).T
    df_points = pd.DataFrame(points, columns=['x', 'y'])

    xrange = [np.amin(x), np.amax(x)]

    canvas = ds.Canvas(plot_width=100, plot_height=150, x_range=xrange, y_range=yrange, x_axis_type='linear', y_axis_type='linear')
    agg = canvas.points(df_points, 'x', 'y')

    point_density = agg.data
    point_density = np.where(np.isnan(point_density), 0, point_density)

    vmax = np.percentile(point_density, 99.9)

    norm = mcolors.Normalize(0, vmax)

    im = ax.imshow(point_density, cmap=cmap, norm=norm, extent=xrange+yrange, aspect='auto', origin='lower')

    return im, vmax


def sci_format_func(value, pos):
    if value == 0:
        return '0'
    else:
        strr = f'{value:.0e}'.replace('e-0', 'e-')

        return strr
    

def plot_point_clouds():

    gt = 'modulus'
    #gt = 'yield_stress'

    # Interpolation order for upscaling Grad-CAM fields. 0 for nearest, 1 for trinilear
    interpolation_order=1

    # Make sure Grad-CAM fields are loaded from Zenodo
    if gt == 'yield_stress':
        heatmap_path = '../train_CNN/yield_stress_0.005/raw/128/'
    else:
        heatmap_path = '../train_CNN/moduluses_0.0015/raw/128/'

    # Make sure local Young's modulus field is generated by running local_modulus_field.py
    field_path = 'local_modulus_field_test_set_32.npy'

    correlations = []

    fields = np.load(field_path)
    non_zeros = ~np.isclose(fields, 0.0)
    res = fields.shape[1]
    n_pillars = fields.shape[0]

    n_conv_blocks = 4
    n_seeds = 5

    fig = plt.figure(figsize=(10, 5))
    gs = gridspec.GridSpec(4, 7, figure=fig, wspace=0, hspace=0, width_ratios=[1, 1, 1, 1, 1, 1, 3])

    plt.subplots_adjust(wspace=0, hspace=0)

    for conv_block_n in range(1, n_conv_blocks + 1):

        y_all = np.ndarray([])
        x_all = np.ndarray([])

        for seed in range(1,n_seeds+1):

            print(conv_block_n, seed)
            
            heatmaps = np.load(f'{heatmap_path}grad_cam_heatmaps_{seed}/conv_block_augmented_{conv_block_n}.npy')
            heatmaps*=np.prod(heatmaps.shape[1:])  # in the calculation of the grad cam fields, mean was used in one place where sum should have been used, which causes the fields to have a wrong scale

            scale_factor = 2**(conv_block_n-1)
            if scale_factor > 1:
                upscaled_heatmaps = np.zeros((n_pillars, res, res, 2*res))
                for i, pillar in enumerate(heatmaps):
                    upscaled_heatmaps[i] = zoom(pillar, zoom=scale_factor, order=interpolation_order)
            else:
                upscaled_heatmaps = heatmaps

            x = fields[non_zeros].flatten()
            y = upscaled_heatmaps[non_zeros].flatten()

            corr = pearsonr(x, y)
            correlations.append(corr.statistic)

            if seed==1:
                x_all = x
                y_all = y
            else:
                x_all = np.vstack((x_all, x))
                y_all = np.vstack((y_all, y))
        
        yrange = [np.percentile(y_all.flatten(), 1), np.percentile(y_all.flatten(), 99)]

        for i, (x, y) in enumerate(zip(x_all, y_all)):
            ax = fig.add_subplot(gs[conv_block_n-1, i])

            im, maximum = plot_density(ax, x, y, yrange)

            width=1
            ax.tick_params(axis="both", which='both', direction="in")
            ax.tick_params(axis='x', which='major', length=3.5, width=width)

            ax.tick_params(axis='y', which='major', length=3.5, width=width)

            if gt == 'modulus' or conv_block_n==4 or conv_block_n==1:
                ax.set_yticks(y_ticks[conv_block_n-1])

            if i == 0:
                ax.yaxis.set_major_formatter(ticker.FuncFormatter(sci_format_func))
                ax.set_ylabel(f'conv block {conv_block_n}\nGrad-CAM')
            else:
                ax.set_yticklabels([])

            if conv_block_n == 1:
                if i==2:
                    ax.set_title(f'(a)\n\nCNN {i+1}')
                else:
                    ax.set_title(f'CNN {i+1}')

            elif conv_block_n == n_conv_blocks and i==2:
                ax.set_xlabel('local Young\'s modulus (GPa)')

            
    fig.subplots_adjust(bottom=0.16)

    cbar_ax = fig.add_axes([0.57, 0.171, 0.2, 0.015])

    cbar = fig.colorbar(im, cax=cbar_ax, orientation='horizontal')

    ax_corr = fig.add_subplot(gs[1:3, 6])
    x_pos = []
    x=0
    for i in range(n_conv_blocks):
        for j in range(n_seeds):
            x_pos.append(x)
            x+=1
        x+=1.5
    x_ticks = [x_pos[i] for i in range(1, len(x_pos), n_seeds)]
    labels = [f'conv block {i + 1}' for i in range(n_conv_blocks)]

    ax_corr.bar(x_pos, correlations, align='center', width=0.8)
    ax_corr.set_ylabel('correlation')

    ax_corr.set_title('(b)')

    # Setting x-ticks and labels
    ax_corr.set_xticks(np.array(x_ticks)+1)
    ax_corr.set_xticklabels(labels, rotation=45, ha='right')
    ax_corr.set_ylim([0, 1])
    ax_corr.yaxis.grid(True)

    pos = ax_corr.get_position()
    # Increase the bottom position slightly and adjust the top to match
    new_pos = [pos.x0, pos.y0 + 0.08, pos.width, pos.height]  # Adjust the 0.05 as needed
    ax_corr.set_position(new_pos)

    tick_positions = [0, 0.25*maximum, 0.5*maximum, 0.75*maximum, maximum]
    cbar.set_ticks(tick_positions)
    cbar.set_ticklabels(['0', '0.25', '0.5', '0.75', '1'])
    cbar.set_label('point density')

    fig.savefig(f'point_cloud_{gt}.pdf', bbox_inches='tight', dpi=450)

    plt.show()

plot_point_clouds()